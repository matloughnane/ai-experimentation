{"version":3,"sources":["../../../node_modules/.pnpm/%40mastra%2Bcore%401.0.4_%40standard-community%2Bstandard-json%400.3.5_%40standard-schema%2Bspec%401.1.0__e15fdfaf85d1846d1444fec06ecbe277/node_modules/%40mastra/core/src/llm/model/registry-generator.ts"],"sourcesContent":["/**\n * Shared provider registry generation logic\n * Used by both the CLI generation script and runtime refresh\n */\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport type { MastraModelGateway, ProviderConfig } from './gateways/base.js';\n\n/**\n * Write a file atomically using the write-to-temp-then-rename pattern.\n * This prevents file corruption when multiple processes write to the same file concurrently.\n *\n * The rename operation is atomic on POSIX systems when source and destination\n * are on the same filesystem.\n *\n * @param filePath - The target file path\n * @param content - The content to write\n * @param encoding - The encoding to use (default: 'utf-8')\n */\nexport async function atomicWriteFile(\n  filePath: string,\n  content: string,\n  encoding: BufferEncoding = 'utf-8',\n): Promise<void> {\n  // Create a unique temp file name using PID, timestamp, and random suffix to avoid collisions\n  const randomSuffix = Math.random().toString(36).substring(2, 15);\n  const tempPath = `${filePath}.${process.pid}.${Date.now()}.${randomSuffix}.tmp`;\n\n  try {\n    // Write to temp file first\n    await fs.writeFile(tempPath, content, encoding);\n\n    // Atomically rename temp file to target path\n    // This is atomic on POSIX when both paths are on the same filesystem\n    await fs.rename(tempPath, filePath);\n  } catch (error) {\n    // Clean up temp file if it exists\n    try {\n      await fs.unlink(tempPath);\n    } catch {\n      // Ignore cleanup errors\n    }\n    throw error;\n  }\n}\n\n/**\n * Fetch providers from all gateways with retry logic\n * @param gateways - Array of gateway instances to fetch from\n * @returns Object containing providers and models records\n */\nexport async function fetchProvidersFromGateways(\n  gateways: MastraModelGateway[],\n): Promise<{ providers: Record<string, ProviderConfig>; models: Record<string, string[]> }> {\n  const allProviders: Record<string, ProviderConfig> = {};\n  const allModels: Record<string, string[]> = {};\n\n  const maxRetries = 3;\n\n  for (const gateway of gateways) {\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const providers = await gateway.fetchProviders();\n\n        // models.dev is a provider registry, not a true gateway - don't prefix its providers\n        const isProviderRegistry = gateway.id === 'models.dev';\n\n        for (const [providerId, config] of Object.entries(providers)) {\n          // For true gateways, use gateway.id as prefix (e.g., \"netlify/anthropic\")\n          // Special case: if providerId matches gateway.id, it's a unified gateway (e.g., azure-openai returning {azure-openai: {...}})\n          // In this case, use just the gateway ID to avoid duplication (azure-openai, not azure-openai/azure-openai)\n          const typeProviderId = isProviderRegistry\n            ? providerId\n            : providerId === gateway.id\n              ? gateway.id\n              : `${gateway.id}/${providerId}`;\n\n          allProviders[typeProviderId] = config;\n          // Sort models alphabetically for consistent ordering\n          allModels[typeProviderId] = config.models.sort();\n        }\n\n        lastError = null;\n        break; // Success, exit retry loop\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < maxRetries) {\n          // Wait before retrying (exponential backoff)\n          const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 5000);\n          await new Promise(resolve => setTimeout(resolve, delayMs));\n        }\n      }\n    }\n\n    // If all retries failed, throw the last error\n    if (lastError) {\n      throw lastError;\n    }\n  }\n\n  return { providers: allProviders, models: allModels };\n}\n\n/**\n * Generate TypeScript type definitions content\n * @param models - Record of provider IDs to model arrays\n * @returns Generated TypeScript type definitions as a string\n */\nexport function generateTypesContent(models: Record<string, string[]>): string {\n  const providerModelsEntries = Object.entries(models)\n    .map(([provider, modelList]) => {\n      const modelsList = modelList.map(m => `'${m}'`);\n\n      // Only quote provider key if it contains special characters (like dashes)\n      const needsQuotes = /[^a-zA-Z0-9_$]/.test(provider);\n      const providerKey = needsQuotes ? `'${provider}'` : provider;\n\n      // Format array based on length (prettier printWidth: 120)\n      const singleLine = `  readonly ${providerKey}: readonly [${modelsList.join(', ')}];`;\n\n      // If single line exceeds 120 chars, format as multi-line\n      if (singleLine.length > 120) {\n        const formattedModels = modelList.map(m => `    '${m}',`).join('\\n');\n        return `  readonly ${providerKey}: readonly [\\n${formattedModels}\\n  ];`;\n      }\n\n      return singleLine;\n    })\n    .join('\\n');\n\n  return `/**\n * THIS FILE IS AUTO-GENERATED - DO NOT EDIT\n * Generated from model gateway providers\n */\n\n/**\n * Provider models mapping type\n * This is derived from the JSON data and provides type-safe access\n */\nexport type ProviderModelsMap = {\n${providerModelsEntries}\n};\n\n/**\n * Union type of all registered provider IDs\n */\nexport type Provider = keyof ProviderModelsMap;\n\n/**\n * Provider models mapping interface\n */\nexport interface ProviderModels {\n  [key: string]: string[];\n}\n\n/**\n * OpenAI-compatible model ID type\n * Dynamically derived from ProviderModelsMap\n * Full provider/model paths (e.g., \"openai/gpt-4o\", \"anthropic/claude-3-5-sonnet-20241022\")\n */\nexport type ModelRouterModelId =\n  | {\n      [P in Provider]: \\`\\${P}/\\${ProviderModelsMap[P][number]}\\`;\n    }[Provider]\n  | (string & {});\n\n/**\n * Extract the model part from a ModelRouterModelId for a specific provider\n * Dynamically derived from ProviderModelsMap\n * Example: ModelForProvider<'openai'> = 'gpt-4o' | 'gpt-4-turbo' | ...\n */\nexport type ModelForProvider<P extends Provider> = ProviderModelsMap[P][number];\n`;\n}\n\n/**\n * Write registry files to disk (JSON and .d.ts)\n * @param jsonPath - Path to write the JSON file\n * @param typesPath - Path to write the .d.ts file\n * @param providers - Provider configurations\n * @param models - Model lists by provider\n */\nexport async function writeRegistryFiles(\n  jsonPath: string,\n  typesPath: string,\n  providers: Record<string, ProviderConfig>,\n  models: Record<string, string[]>,\n): Promise<void> {\n  // 0. Ensure directories exist\n  const jsonDir = path.dirname(jsonPath);\n  const typesDir = path.dirname(typesPath);\n  await fs.mkdir(jsonDir, { recursive: true });\n  await fs.mkdir(typesDir, { recursive: true });\n\n  // 1. Write JSON file atomically to prevent corruption from concurrent writes\n  const registryData = {\n    providers,\n    models,\n    version: '1.0.0',\n  };\n\n  await atomicWriteFile(jsonPath, JSON.stringify(registryData, null, 2), 'utf-8');\n\n  // 2. Generate .d.ts file with type-only declarations (also atomic)\n  const typeContent = generateTypesContent(models);\n  await atomicWriteFile(typesPath, typeContent, 'utf-8');\n}\n"],"names":[],"mappings":"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"}